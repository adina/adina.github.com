<p>Recently, I&#8217;ve been spending a lot of time combining overlapping short sequencing reads (100 bp) into longer sequences called contigs. Since I&#8217;m doing this without any reference genomes, this is called de novo assembly. (Here&#8217;s a really nice introduction into the subject from the University of Maryland, <a href='http://www.cbcb.umd.edu/research/assembly_primer.shtml'>Primer</a>.</p>

<p>The datasets I&#8217;m working with are challenging in a couple unique ways. Firstly, they&#8217;re ginormous, 3 billion reads (300 billion bp or the equivalent of 75,000 E. coli genomes). This has been the subject of many of my pal and previous boss, C. Titus Brown&#8217;s blogposts, <a href='http://ivory.idyll.org/blog/'>Living in an Ivory Basement</a>). We think we have a good grasp on how to process and assemble this data nowadays. One of the key things I realized while dealing with this first challenge was the second problem&#8230;and that is, how do we know what we&#8217;re getting out is right? Are the assemblies we produce correct? Basically, are the methods we are using doing what I think they are?</p>

<p>The idea of a &#8220;unit test&#8221; has been one that I have been learning a lot about as I am starting to both produce and teach more scientific coding. For those who are starting out in this field, I&#8217;ve basically infiltrated after three years &#8211; its doable and very rewarding. Looking back to my time as an experimental microbiologist, this is very analogous to the requirement of controls for an experiment in that one would ALWAYS require. In bioinformatics, I have adjusted my perspective to crave the same reassurance.</p>

<p>In choosing such &#8220;controls&#8221; for metagenomic datasets, many others have chosen simulated metagenomes (mixtures of reference genomes with some error profiles mixed in). I think these datasets are useful but the problem is that it does not reflect real data. We&#8217;ve seen systematic biases in metagenomic datasets which due to their seemingly random nature cannot be captured in a simulated error profile.</p>

<p>Fortunately, the folks at the NIH Human Microbiome Project have made a push for protocol development and validation. This has resulted in an immensely useful &#8220;control&#8221; mock genome for me. This dataset is the sequencing of an experimental mixture of DNA extracted from isolates. (There are actually two datasets, an even and staggered mixture). Although this mock genome is NOT a metagenome, it has two properties that are wonderful: first, it has the dirty noisy characteristics of a real metagenome since it has actually gone through the sequencing process and secondly, it has a set of references with which to examine any analysis.</p>

<p>I want to highlight a couple use cases where I have found this dataset (or something like it) to be critical.</p>

<h3 id='1_evaluation_of_digital_normalization_and_partitioning_for_assembly'>#1 Evaluation of Digital Normalization and Partitioning for Assembly</h3>

<p>Briefly, our approaches efficiently sift through metagenomic data and eliminate redundant information above a user-defined threshold (i.e., you only need to see an overlap X number of times before you&#8217;re sure that it should be assembled). We then break apart pieces of the total metagenome which are not connected (i.e. separating genome A and B). We then assemble each of these &#8220;partitions&#8221; independently. I needed to evaluate what was happening when we&#8217;re discarding data and manipulating data in different groups. Using the mock dataset, I assembled the unprocessed dataset with a variety of assemblers and compared this to the processed dataset assembled. I could determine the similarity between assemblies and most importantly, the recovery of reference genomes. Awesomely, I found that after I processed the mock metagenome, I got better assemblies!</p>

<p><img alt='Table 1' src='https://raw.github.com/adina/adina.github.com/master/figures/2012-11-06-control/table1.png' /></p>

<p>Table 1. Assembly comparisons of unfiltered (UF) and filtered (F) or filtered/partitioned (FP) HMP mock datasets using different assemblers (Velvet (V), MetaIDBA (M) and SOAPdenovo (S)). Assembly content similarity is based on the fraction of alignment of assemblies and similarly, the coverage of reference genomes is based on the alignment of assembled contigs to reference genomes (RG).</p>

<h3 id='2_identifying_housekeeping_genes_in_assembled_contigs'>#2 Identifying Housekeeping Genes in Assembled Contigs</h3>

<p>I had a problem in that I needed to determine how to compare different metagenomic assemblies of two different samples. I decided I would normalize by some known housekeeping genes as a proxy for number of genomes. The problem is that I wasn&#8217;t sure how accurate a reference based annotation (using HMMER) of various gene models (recA, rpoB, gyrB, etc.) against my assembled contigs would fair. Using the mock metagenome (containing 21 genomes), I was able to determine that estimates of the mock community there were some gene models, gyrB and rpoB, (because of their length) were not candidates. These would overestimate the total number of genomes.</p>

<p><img alt='Table 2' src='https://raw.github.com/adina/adina.github.com/master/figures/2012-11-06-control/table2.png' /></p>

<p>Table 2. Number of housekeeping genes identified in HMP mock community reference genomes and assembled (Velvet) contigs.</p>

<p>If I&#8217;ve convinced you that you&#8217;d like to control everything in your life too, you probably want to know where you can get this data? It&#8217;s a bit hard to find. Google would most likely bring you the following description of lots of datasets you could play with (mostly dealing with 16S amplicon sequencing):</p>

<blockquote>
<p><a href='http://hmpdacc.org/doc/HMP_Data_Set_Documentation.pdf'>http://hmpdacc.org/doc/HMP_Data_Set_Documentation.pdf</a></p>
</blockquote>

<p>I couldn&#8217;t get the download links to work and cannot find the described 4 sequencing datasets for a mock community. What I can help you with is a link (thanks to Mihai Pop) to the SRA Illumina mock genomes:</p>

<blockquote>
<p>Staggered</p>
</blockquote>

<blockquote>
<p><a href='http://www.ncbi.nlm.nih.gov/sra/SRX055381'>http://www.ncbi.nlm.nih.gov/sra/SRX055381</a></p>
</blockquote>

<blockquote>
<p>Even</p>
</blockquote>

<blockquote>
<p><a href='http://www.ncbi.nlm.nih.gov/sra/SRX055380'>http://www.ncbi.nlm.nih.gov/sra/SRX055380</a></p>
</blockquote>

<blockquote>
<p>Reference Genomes</p>
</blockquote>

<blockquote>
<p><a href='ftp://ftp.hgsc.bcm.tmc.edu/pub/misc/HMP/mock/mock.all.genome.fa'>FTP for reference genomes</a></p>
</blockquote>

<p>Some information on relative abundance of each genome in the mixture can be found here (thanks to Stephen Turner!)</p>

<blockquote>
<p><a href='http://downloads.hmpdacc.org/data/HMMC/HMPRP_sT1-Mock.pdf'>http://downloads.hmpdacc.org/data/HMMC/HMPRP_sT1-Mock.pdf</a></p>
</blockquote>

<p>Though I caution you that I do not find these abundances to be accurate based on my assembly of this dataset.</p>

<p>Also, in case you don&#8217;t know how to work with the SRA or get stuck in what is the perpetual link-loop purgatory within the SRA (as I often do), I&#8217;ve also placed them here:</p>

<p><a href='http://lyorn.idyll.org/~adina/SRR172902.fastq.gz'>Even HMP mock fastq</a></p>

<p><a href='http://lyorn.idyll.org/~adina/SRR172903.fastq.gz'>Staggered HMP mock fastq</a></p>

<p>I hope you enjoy control as much as I do.</p>

<p>Signing off my very first blog post (woot!),</p>

<p>Adina</p>